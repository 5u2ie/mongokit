= MongoKit Tutorial =

== Simple Example == 

>>> from mongokit import *

>>> import datetime

>>> class BlogPost(MongoDocument):
...     db_name = 'test'
...     collection_name = 'tutorial'
...     structure = {
...             'title':unicode,
...             'body':unicode,
...             'author':unicode,
...             'date_creation':datetime.datetime,
...             'rank':int
...     }
...     required_fields = ['title','author', 'date_creation']
...     default_values = {'rank':0, 'date_creation':datetime.datetime.utcnow}
... 

A MongoDocument take a `db_name` and a `collection_name` as attribute. Next, you have to specify a structure.
The structure is a simply dictionnary with python type. In this example, `title` must be unicode and `rank`
must be an int.

Optionaly, you can add some descriptors. In order to specify fields wich are required, just add a `required_fields`
attribute. This is a simple list wich list all required_fields (ie, those field must not be None when validating).

Same thing with the `default_values` attribute. This is a dict where you can specify default values. Note that
you can pass callable object (like a datetime).

>>> bp = BlogPost()
>>> bp # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
{'body': None, 'title': None, 'date_creation': datetime.datetime(...), 'rank': 0, 'author': None} 

Not that `date_creation` was automaticly filled by `utcnow()` and rank is 0.

>>> bp['title'] = "my first blog post"
>>> bp.validate() 
Traceback (most recent call last):
...
SchemaTypeError: title must be an instance of unicode not str

`str` type is not authorized, you must use unicode : 

>>> bp['title'] = u"my first blog post"

`validate` method will check if required fields are set :

>>> bp.validate()
Traceback (most recent call last):
...
RequireFieldError: author is required

>>> bp['author'] = u'myself'
>>> bp.validate()

Note that `save` will call the `validate` method, so you don't have to validate each time.

>>> bp.save() # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
{'body': None, 'title': u'my first blog post', 'author': u'myself', 'rank': 0, '_id': ..., 'date_creation': datetime.datetime(...)}

== Query ==

There 4 way to query a collection `all()`, `one()`, `fetch()`, `fetch_one`.
`all()` and `fetch()` return a cursor of collection.  A cursor is an container
wich lazy evaluate the results. A cursor is acting like an iterator.
`one()` and `fetch_one()` return the document itself.

All theses method can take a query as argument. A query is a simple dict. Please,
see the mongodb and the pymongo documentation for further details.

=== all() ===

`all()` without argument will return a cursor of all documents of the collection.
If a query is passed, it will return a cursor all documents wich match the query.
The query is launch against the db and collection of the object.

`all()` takes the same arguments than the the pymongo.collection.find method.

>>> bp = BlogPost()
>>> bp['title'] = u"my second blog post"
>>> bp['author'] = u"myself"
>>> bp.save()

>>> for post in  BlogPost.all():
...     print post['title']
u'my first blog post'
u'my second blog post'


>>> for post in  BlogPost.all({'title':'my first blog post'}):
...     print post['title']
u'my first blog post'


=== one() ===

`one()` act like `all()` but will raise a `mongokit.MultipleResultsFound` exception if
there is more than one result.

>>> BlogPost.one()
Traceback (most recent call last):
...
MultipleResultsFound: 2 results found

>>> BlogPost.one({'title':'my first blog post'}) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
{'body': None, 'title': u'my first blog post', 'author': u'myself', 'rank': 0, '_id': ..., 'date_creation': datetime.datetime(...)}

If no document is found, `one()` returns None

=== fetch() ===

Unlike `all()`, `fetch()` will return only documents wich match the structure of the Document.

>>> all_blog_posts = BlogPost.fetch()

This will return only all blog post (wich have 'title', 'body', 'author', 'date_creation', 'rank' as fields).
This is an helper for :

>>> BlogPost.all({'$where':"'title' in this && 'body' in this && 'author' in this && 'date_creation' in this && 'rank' in this"})

=== fetch_one() ===

Juste like `fetch()` but raise a  `mongokit.MultipleResultsFound` exception if
there is more than one result.

== Dot notation == 

If you want to use the dot notation (ala json), you must set the
`use_dot_notation` attribute to True:

>>> class TestDotNotation(MongoDocument):
...     structure = {
...         "foo":{ "bar":unicode}
...     }
...     use_dot_notation=True

>>> doc = TestDotNotation()
>>> doc.foo.bar = u"bla"
>>> doc
{"foo":{"bar":u"bla}}

== DiffÃ©rence beetween {} and the type dict ==

{} is used for describing the structure like {"foo":unicode, "bar":int}

>>> class Person(MongoDocument):
...    structure = {
...        "biography": {"foo":unicode", "bar":int"}
...    }


If you don't specify the structure :

>>> class Person(MongoDocument):
...    structure = {
...        "biography": {}
...    }

You won't be able to do that because "foo" is not defined into the structure.

>>> bob = Person()
>>> bob[u"biography"][u"foo"] = u"bla"
mongokit.mongo_exceptions.StructureError: unknown fields : ['foo']


If you want to add new items to a dict if they're not defined, you must use the dict type instead :

>>> class Person(MongoDocument):
...    structure = {
...        "biography": dict
...    }

>>> bob = Person()
>>> bob[u"biography"][u"foo"] = u"bla"
>>> bob.save()

Using dict type is useful if you don't know what field will be added *and* what will be the type of the field.
If you know the type of the field, it's better to do that :

>>> class Person(MongoDocument):
...    structure = {
...        "biography": {unicode:unicode}
...    }

This will add another layer to validate the content. See "validate keys" section for more informations.

== Adding custom types ==

>>> import mongokit
>>> mongokit.authorized_types.append(str)

>>> class MyDoc(MongoDocument):
...     structure = {
...             'foo':str,
...     }
...

>>> mydoc = MyDoc()
>>> mydoc['foo'] = 'bla'
>>> mydoc.validate()

== validate keys ==

If the value of key is not known but we want to validate some deeper structure, 
we use the "$<type>" descriptor :

>>> class MyDoc(MongoDocument):
...    structure = {
...        "key1":{
...            unicode:{
...                "bla":int,
...                "bar":{unicode:int}
...            },
...        },
...        "bla":float,
...    }
...    required_fields = ["key1.$unicode.bla"]
...

Not that if you use python type as key in structure, generate_skeleton
won't be able to build the entired underline structure :

>>> MyDoc() == {'key1': {}, 'bla': None}
True

So, default_values nor signals will work.

== MongokitOperator ==

It is possible to add another layer of validation to fields.

=== OR operator ==

Let's say that we have a field wich can be unicode or int or a float.
We can use the OR operator to tell MongoKit to validate the field :

>>> from mongokit import OR
>>> class Account(MongoDocument): 
...     structure = { 
...         "balance": {'foo': OR(unicode, int, float)} 
...     } 

>>> account = Account()
>>> account['foo'] = u'3.0'
>>> account.validate()
>>> account['foo'] = 3.0
>>> account.validate()

but :

>>> account['foo'] = datetime.now()
Traceback (most recent call last):
...
SchemaTypeError: 'foo' must be an instance of <unicode or int or float> not datetime

=== NOT operator ===

You can also use the NOT operator to tell MongoKit that you don't want a such type
for a field :

>>> from mongokit import NOT
>>> from datetime import datetime
>>> class Account(MongoDocument): 
...     structure = { 
...         "balance": {'foo': NOT(unicode, datetime)} 
...     } 

>>> account = Account()
>>> account['foo'] = 3
>>> account.validate()
>>> account['foo'] = 3.0
>>> account.validate()

and :

>>> account['foo'] = datetime.now()
Traceback (most recent call last):
...
SchemaTypeError: 'foo' must be an instance of <not unicode, not datetime> not datetime

>>> account['foo'] = u'3.0'
Traceback (most recent call last):
...
SchemaTypeError: 'foo' must be an instance of <not unicode, not datetime> not unicode

=== IS operator ===

Sometime, you might want to force a fields to be in a specifique value. The IS operator
must be use for this purpose :

>>> from mongokit import IS
>>> class Account(MongoDocument): 
...     structure = { 
...         "flag": {'foo': IS(u'spam', u'controversy', u'phishing')} 
...     } 

>>> account = Account()
>>> account['foo'] = u'spam'
>>> account.validate()
>>> account['flag'] = u'phishing'
>>> account.validate()

and :

>>> account['flag'] = u'foo'
Traceback (most recent call last):
...
SchemaTypeError: 'flag' must be in [u'spam', u'controversy', u'phishing'] not foo

== Adding complexe validation == 

If the use of a validator is not enougth, you can overload the validation method
to feet your needs.

Example the following document:

>>> class MyDoc(MongoDocument):
...     structure={
...             "foo":int,
...             "bar":int,
...             "baz":unicode,
...     }
... 

We want to be sur that before saving our object, foo is greater than bar and baz is
unicode(foo). Do do that, we juste overload the validation method :

    def validate(self):
        assert self['foo'] > self['bar']
        assert self['baz'] == unicode(self['foo'])
        super(MyDoc, self).validate(self)



